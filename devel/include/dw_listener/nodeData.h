// Generated by gencpp from file dw_listener/nodeData.msg
// DO NOT EDIT!


#ifndef DW_LISTENER_MESSAGE_NODEDATA_H
#define DW_LISTENER_MESSAGE_NODEDATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace dw_listener
{
template <class ContainerAllocator>
struct nodeData_
{
  typedef nodeData_<ContainerAllocator> Type;

  nodeData_()
    : tagAddress()
    , rangeNum(0)
    , timeOfReception(0)
    , distance(0)
    , Xcoord(0)
    , Ycoord(0)
    , clockOffset(0)
    , serviceData(0)
    , Xaccel(0)
    , Yaccel(0)
    , Zaccel(0)  {
    }
  nodeData_(const ContainerAllocator& _alloc)
    : tagAddress(_alloc)
    , rangeNum(0)
    , timeOfReception(0)
    , distance(0)
    , Xcoord(0)
    , Ycoord(0)
    , clockOffset(0)
    , serviceData(0)
    , Xaccel(0)
    , Yaccel(0)
    , Zaccel(0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _tagAddress_type;
  _tagAddress_type tagAddress;

   typedef int64_t _rangeNum_type;
  _rangeNum_type rangeNum;

   typedef int64_t _timeOfReception_type;
  _timeOfReception_type timeOfReception;

   typedef int64_t _distance_type;
  _distance_type distance;

   typedef int64_t _Xcoord_type;
  _Xcoord_type Xcoord;

   typedef int64_t _Ycoord_type;
  _Ycoord_type Ycoord;

   typedef int64_t _clockOffset_type;
  _clockOffset_type clockOffset;

   typedef int64_t _serviceData_type;
  _serviceData_type serviceData;

   typedef int64_t _Xaccel_type;
  _Xaccel_type Xaccel;

   typedef int64_t _Yaccel_type;
  _Yaccel_type Yaccel;

   typedef int64_t _Zaccel_type;
  _Zaccel_type Zaccel;





  typedef boost::shared_ptr< ::dw_listener::nodeData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::dw_listener::nodeData_<ContainerAllocator> const> ConstPtr;

}; // struct nodeData_

typedef ::dw_listener::nodeData_<std::allocator<void> > nodeData;

typedef boost::shared_ptr< ::dw_listener::nodeData > nodeDataPtr;
typedef boost::shared_ptr< ::dw_listener::nodeData const> nodeDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::dw_listener::nodeData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::dw_listener::nodeData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::dw_listener::nodeData_<ContainerAllocator1> & lhs, const ::dw_listener::nodeData_<ContainerAllocator2> & rhs)
{
  return lhs.tagAddress == rhs.tagAddress &&
    lhs.rangeNum == rhs.rangeNum &&
    lhs.timeOfReception == rhs.timeOfReception &&
    lhs.distance == rhs.distance &&
    lhs.Xcoord == rhs.Xcoord &&
    lhs.Ycoord == rhs.Ycoord &&
    lhs.clockOffset == rhs.clockOffset &&
    lhs.serviceData == rhs.serviceData &&
    lhs.Xaccel == rhs.Xaccel &&
    lhs.Yaccel == rhs.Yaccel &&
    lhs.Zaccel == rhs.Zaccel;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::dw_listener::nodeData_<ContainerAllocator1> & lhs, const ::dw_listener::nodeData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace dw_listener

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::dw_listener::nodeData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dw_listener::nodeData_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::dw_listener::nodeData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::dw_listener::nodeData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dw_listener::nodeData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dw_listener::nodeData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::dw_listener::nodeData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "de0a8cf43c7496a6d5ba6e0f18822096";
  }

  static const char* value(const ::dw_listener::nodeData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xde0a8cf43c7496a6ULL;
  static const uint64_t static_value2 = 0xd5ba6e0f18822096ULL;
};

template<class ContainerAllocator>
struct DataType< ::dw_listener::nodeData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "dw_listener/nodeData";
  }

  static const char* value(const ::dw_listener::nodeData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::dw_listener::nodeData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "\n"
"string tagAddress\n"
"int64 rangeNum\n"
"int64 timeOfReception\n"
"int64 distance\n"
"int64 Xcoord\n"
"int64 Ycoord\n"
"int64 clockOffset\n"
"int64 serviceData\n"
"int64 Xaccel\n"
"int64 Yaccel\n"
"int64 Zaccel\n"
;
  }

  static const char* value(const ::dw_listener::nodeData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::dw_listener::nodeData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.tagAddress);
      stream.next(m.rangeNum);
      stream.next(m.timeOfReception);
      stream.next(m.distance);
      stream.next(m.Xcoord);
      stream.next(m.Ycoord);
      stream.next(m.clockOffset);
      stream.next(m.serviceData);
      stream.next(m.Xaccel);
      stream.next(m.Yaccel);
      stream.next(m.Zaccel);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct nodeData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::dw_listener::nodeData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::dw_listener::nodeData_<ContainerAllocator>& v)
  {
    s << indent << "tagAddress: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.tagAddress);
    s << indent << "rangeNum: ";
    Printer<int64_t>::stream(s, indent + "  ", v.rangeNum);
    s << indent << "timeOfReception: ";
    Printer<int64_t>::stream(s, indent + "  ", v.timeOfReception);
    s << indent << "distance: ";
    Printer<int64_t>::stream(s, indent + "  ", v.distance);
    s << indent << "Xcoord: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Xcoord);
    s << indent << "Ycoord: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Ycoord);
    s << indent << "clockOffset: ";
    Printer<int64_t>::stream(s, indent + "  ", v.clockOffset);
    s << indent << "serviceData: ";
    Printer<int64_t>::stream(s, indent + "  ", v.serviceData);
    s << indent << "Xaccel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Xaccel);
    s << indent << "Yaccel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Yaccel);
    s << indent << "Zaccel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Zaccel);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DW_LISTENER_MESSAGE_NODEDATA_H
